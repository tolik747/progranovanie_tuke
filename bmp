char* bmp_decrypt(const char* key, const unsigned char* text)
{
    
    if (text == NULL ||strlen(key) == 0 || key == NULL)
    {
        return NULL;
    }
    
    for (int i = 0; key[i] != '\0'; i++) {
        if (!isalpha(key[i]) && key[i] != '.' && key[i] != '!' && key[i] != ',' && key[i] != ' ') {
            return NULL;
        }
    }
    
    int text_length = strlen((const char*)text);
    //int text_length=0;
    int key_length=strlen(key);
    char* binary_text = (char*)calloc((text_length * 8) + 1, sizeof(char));
    char* encrypted_text = (char*)calloc(text_length / 2 + 1, sizeof(char));
    if (binary_text == NULL || encrypted_text == NULL) {
        free(binary_text);  
        free(encrypted_text);
        return NULL;
    }

    for(size_t i = 0; i < text_length ; i++) 
    {
            unsigned char current_char = text[i];
            for(int j = 7; j >= 0; j--) 
            {
                binary_text[(i * 8) + (7 - j)] = ((current_char >> j) & 1) + '0';   
            }

            char pair1[5];
            char pair2[5];
            pair1[4] = '\0';
            pair2[4]='\0';
            char bits[9];
            
            for(int f = 0; f < 4; f++)
            {
                pair1[f] = binary_text[i * 8 + f];
            }
            for(int g = 4; g < 8; g++)
            {
                pair2[g-4] = binary_text[(i * 8) + g];
                
            }
            //xor
            char xor_result[5];
            xor_result[4] = '\0';
            for(int k = 0; k < 4; k++)
            {
                xor_result[k] = (pair1[k] != pair2[k]) ? '1' : '0';
            }
            for(int l = 0; l < 4; l++)
            {
                pair2[l] = xor_result[l];
            }
            //зміна бітів 
        int one=pair1[0];
        int two=pair1[1];
        int three=pair1[2];
        int four=pair1[3];
        pair1[0]=two;
        pair1[1]=one;
        pair1[2]=four;
        pair1[3]=three;
        //копіювання в чар біт
        strcpy(bits,pair1);
        strcat(bits,pair2);
        //перепис в букви
        char decrypted_char = 0;
        for(int let=0;let<8;let++)
        {
            decrypted_char <<= 1;
            if(bits[let]=='1')
            {
                decrypted_char|=1;
            }
        }
        encrypted_text[i]=decrypted_char;
    }
    //printf("%s\n",encrypted_text);
    for(int i=0,j=0;i<text_length;i++)
    {
        char let=encrypted_text[i];
        if(isalpha(let))
        {
            char caps=toupper(key[j%key_length])-'A';
            char case_ap = isupper(let) ? 'A' : 'a';
           
            encrypted_text[i]=((let - case_ap - caps + 26)%26) + case_ap;
            j++;
        }else{
             encrypted_text[i]=let;
             
        }
    }
    //printf("%s\n",encrypted_text);
    int countik = text_length; 
    char* mirrored_text = (char*)calloc(text_length + 1, sizeof(char));
    if (mirrored_text == NULL) {
        
        return NULL;
    }
    int ss = 0;
    for (int i = countik - 1; i >= 0; i--) 
    {
        mirrored_text[ss] = encrypted_text[i];
        ss++;
    }
    mirrored_text[ss] = '\0';
    free(binary_text);
    free(encrypted_text);
    return mirrored_text;    
}
